## 📌 HTTP 기초

### NET-001

HTTP에 대해 설명해 주세요.

- HTTP는 웹에서 클라이언트와 서버가 요청(Request)과 응답(Response)을 교환하는 애플리케이션 계층 프로토콜입니다.
- 텍스트 기반이며 TCP 위에서 동작합니다.

```jsx
OSI 7계층 중 7계층(응용 계층)에 속하며,TCP/IP 위에서 동작한다.

- 텍스트 기반이란?
HTTP 메시지는 사람이 읽을 수 있는 문자열 형태로 구성되어 있다.
ex)
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome
명령어와 헤더를 문자열로 표현하기 때문에 "텍스트 기반"이라 불린다.
```

### NET-002

HTTP의 특성인 Stateless에 대해 설명해 주세요.

- Stateless란 서버가 요청 간의 상태를 저장하지 않는다는 뜻으로, 각 요청은 독립적으로 처리됩니다.

이로 인해 확장성과 단순성이 높아집니다.

```jsx
즉, 서버는 “이전 요청에서 로그인 했었는지”, “이전에 어떤 페이지를 봤는지” 등을 기본적으로 모른다.
모든 요청은 아래처럼 독립적으로 처리된다.

[요청 1] GET /page1
[요청 2] GET /page2   ← 서버는 이게 같은 사용자인지 모름

단점: 상태가 없으므로 로그인 상태 같은 “연속된 맥락”이 필요할 때는
쿠키(Cookie), 세션(Session), 토큰(JWT) 등을 이용해서 “상태를 흉내내야” 한다.
```

### NET-003

Stateless와 Connectionless에 대해 설명해 주세요.

- Stateless는 “요청 간 상태를 유지하지 않음”, Connectionless는 “요청 후 연결을 유지하지 않음”을 의미합니다.
- 둘 다 HTTP의 특성이지만 별개의 개념입니다.

```jsx
stateless : 기억을 안하는 논리적 틍성
- 응답 후 사용자의 상태를 따로 보존하지 않는다. = 모든 요청이 독립적으로 처리 된다.
Connectionless : 문을 닫는 물리적 연결 특성 
- 연결이 끝나면 문을 닫는다.= 응답 후 TCP 연결을 종료해서 연결시 새로 연결을 생성한다.
```

### NET-004

왜 HTTP는 Stateless 구조를 채택하고 있을까요?

- Stateless 구조는 서버 부담을 줄이고, 다수의 클라이언트를 빠르게 처리하기 위함입니다.

필요 시 쿠키나 세션으로 상태를 보완합니다.

```jsx
서버를 단순하게 유지하게 위해 stateless 로 설계했다.
하지만 이 값을 유지하기 위한 쿠키/세션/JWT가 생겼다.
```

### NET-005

Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?

- Connectionless로 인한 비효율은 “Persistent Connection(keep-alive)”로 해결합니다.

여러 요청을 하나의 TCP 연결로 처리합니다.

```jsx
HTTP/1.0은 매 요청마다 TCP 연결을 새로 맺었다.
웹페이지를 불러올 때 여러 개 요청이 필요한데 그럴 때마다 새 연결을 맺어 속도가 느려졌다.
HTTP/1.1부터 “Connection: keep-alive” 헤더가 도입되어,
한 번의 TCP 연결로 여러 요청을 처리할 수 있게 되었다.
```

### NET-006

TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?

- TCP의 keep-alive는 커넥션의 생존 확인용이고,
- HTTP의 keep-alive는 같은 TCP 연결을 여러 요청에 재사용하기 위한 기능입니다.

```jsx
TCP : 연결이 죽었는지 감시
- 주기적으로 패킷을 보내서 응답이 있으면 유지 없으면 문을 닫는다.
HTTP : 문을 열어둔 채 여러 번 대화하는 방식
- 요청 완료 후 일정 시간 대기후 닫는다.
```
